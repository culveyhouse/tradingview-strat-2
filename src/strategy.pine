// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tradingview-strat-2

//@version=6
//@description="Takes one trade at a time after a random wait, flips a coin for direction, and uses a random 1:1 tick stop/limit. Adds debug table for visibility."

strategy("Random Wait RR 1:1",
  overlay=true,
  pyramiding=0,
  initial_capital=10000,
  default_qty_type=strategy.percent_of_equity,
  default_qty_value=10,
  process_orders_on_close=true,
  commission_type=strategy.commission.percent,
  commission_value=0.0)

// ══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ══════════════════════════════════════════════════════════════════════════════

group_timing = "Random Timing"
group_risk = "Risk Management"
group_direction = "Direction"

i_min_wait_minutes = input.int(5, "Minimum wait (minutes)", minval=1, maxval=240, group=group_timing)
i_max_wait_minutes = input.int(60, "Maximum wait (minutes)", minval=1, maxval=480, group=group_timing)

i_min_tick_distance = input.int(20, "Minimum tick distance", minval=1, maxval=500, group=group_risk)
i_max_tick_distance = input.int(50, "Maximum tick distance", minval=1, maxval=500, group=group_risk)

i_allow_long = input.bool(true, "Allow long entries", group=group_direction)
i_allow_short = input.bool(true, "Allow short entries", group=group_direction)

// Ensure ranges remain valid even if the user swaps min/max values
validated_min_wait = math.min(i_min_wait_minutes, i_max_wait_minutes)
validated_max_wait = math.max(i_min_wait_minutes, i_max_wait_minutes)
validated_min_ticks = math.min(i_min_tick_distance, i_max_tick_distance)
validated_max_ticks = math.max(i_min_tick_distance, i_max_tick_distance)

// ══════════════════════════════════════════════════════════════════════════════
// STATE
// ══════════════════════════════════════════════════════════════════════════════

var int wait_end_time_ms = na
var int active_tick_distance = na
var bool was_in_position = false
var string last_direction = "None"

// Returns the next time (in ms) when entries are allowed
next_wait_end(time_ms) =>
    wait_minutes = math.round(math.random(validated_min_wait, validated_max_wait))
    wait_minutes := math.max(validated_min_wait, math.min(wait_minutes, validated_max_wait))
    time_ms + wait_minutes * 60 * 1000

// Initialize the first waiting window
if na(wait_end_time_ms)
    wait_end_time_ms := next_wait_end(time)

// ══════════════════════════════════════════════════════════════════════════════
// ENTRY LOGIC
// ══════════════════════════════════════════════════════════════════════════════

can_trade = i_allow_long or i_allow_short
cooldown_done = not na(wait_end_time_ms) and time >= wait_end_time_ms
ready_for_entry = strategy.position_size == 0 and cooldown_done and can_trade

if ready_for_entry
    // Choose random tick distance for the 1:1 stop/limit
    active_tick_distance := math.round(math.random(validated_min_ticks, validated_max_ticks))
    active_tick_distance := math.max(validated_min_ticks, math.min(active_tick_distance, validated_max_ticks))

    // Flip a coin for direction while respecting disabled sides
    draw_long = math.random(0.0, 1.0) >= 0.5
    is_long = i_allow_long and i_allow_short ? draw_long : i_allow_long

    entry_id = is_long ? "Random Long" : "Random Short"
    last_direction := entry_id
    strategy.entry(entry_id, is_long ? strategy.long : strategy.short)

// ══════════════════════════════════════════════════════════════════════════════
// EXIT LOGIC
// ══════════════════════════════════════════════════════════════════════════════

long_active = strategy.position_size > 0
short_active = strategy.position_size < 0

if long_active and not na(active_tick_distance)
    stop_price_long = strategy.position_avg_price - active_tick_distance * syminfo.mintick
    limit_price_long = strategy.position_avg_price + active_tick_distance * syminfo.mintick
    strategy.exit("Long Exit", from_entry="Random Long", stop=stop_price_long, limit=limit_price_long)

if short_active and not na(active_tick_distance)
    stop_price_short = strategy.position_avg_price + active_tick_distance * syminfo.mintick
    limit_price_short = strategy.position_avg_price - active_tick_distance * syminfo.mintick
    strategy.exit("Short Exit", from_entry="Random Short", stop=stop_price_short, limit=limit_price_short)

// ══════════════════════════════════════════════════════════════════════════════
// RESET AFTER EXIT
// ══════════════════════════════════════════════════════════════════════════════

if was_in_position and strategy.position_size == 0
    active_tick_distance := na
    wait_end_time_ms := next_wait_end(time)

was_in_position := strategy.position_size != 0

// ══════════════════════════════════════════════════════════════════════════════
// PLOTTING (minimal for clarity)
// ══════════════════════════════════════════════════════════════════════════════

plotshape(ready_for_entry, title="Entry Ready", text="Ready", style=shape.triangleup, location=location.bottom, color=color.new(color.teal, 30), size=size.tiny)

// ══════════════════════════════════════════════════════════════════════════════
// DEBUG PANEL
// ══════════════════════════════════════════════════════════════════════════════

var table debug_table = table.new(position.top_right, 1, 1, frame_color=color.new(color.silver, 70), border_width=1)

wait_remaining_min = na(wait_end_time_ms) ? na : (wait_end_time_ms - time) / 60000.0
wait_text = na(wait_remaining_min) ? "n/a" : wait_remaining_min > 0 ? str.tostring(math.round(wait_remaining_min, 2)) + " min" : "Elapsed"
close_vs_stop_text = long_active ? str.tostring(close > strategy.position_avg_price) : short_active ? str.tostring(close < strategy.position_avg_price) : "n/a"
ticks_to_stop = not na(active_tick_distance) and long_active ? (close - (strategy.position_avg_price - active_tick_distance * syminfo.mintick)) / syminfo.mintick :
  not na(active_tick_distance) and short_active ? ((strategy.position_avg_price + active_tick_distance * syminfo.mintick) - close) / syminfo.mintick :
  na
live_tick_text = na(ticks_to_stop) ? "n/a" : str.tostring(math.round(ticks_to_stop, 2))

debug_text = str.format("Random Wait RR 1:1\nReady: {0}\nIn Position: {1}\nCooldown Done: {2}\nDirection: {3}\nActive Tick Dist: {4}\nWait Ends: {5}\nCan Trade: {6}\nClose > Stop?: {7}\nTicks To Stop: {8}",
  ready_for_entry,
  was_in_position,
  cooldown_done,
  last_direction,
  na(active_tick_distance) ? "n/a" : str.tostring(active_tick_distance),
  na(wait_end_time_ms) ? "n/a" : wait_text,
  can_trade,
  close_vs_stop_text,
  live_tick_text)

table.cell(debug_table, 0, 0, debug_text, text_size=size.normal, text_color=color.white, bgcolor=color.new(color.black, 65))

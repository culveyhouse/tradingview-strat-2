// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tradingview-strat-2

//@version=6
//@description="Takes one trade at a time after a random wait, flips a coin for direction, and uses a random 1:1 tick stop/limit. Adds debug table for visibility."

strategy("Random Wait RR 1:1",
  overlay=true,
  pyramiding=0,
  initial_capital=10000,
  default_qty_type=strategy.percent_of_equity,
  default_qty_value=10,
  process_orders_on_close=true,
  commission_type=strategy.commission.percent,
  commission_value=0.0)

// ══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ══════════════════════════════════════════════════════════════════════════════

group_timing = "Random Timing"
group_risk = "Risk Management"
group_direction = "Direction"

i_min_wait_minutes = input.int(5, "Minimum wait (minutes)", minval=1, maxval=240, group=group_timing)
i_max_wait_minutes = input.int(60, "Maximum wait (minutes)", minval=1, maxval=480, group=group_timing)

i_min_tick_distance = input.int(20, "Minimum tick distance", minval=1, maxval=500, group=group_risk)
i_max_tick_distance = input.int(50, "Maximum tick distance", minval=1, maxval=500, group=group_risk)

i_allow_long = input.bool(true, "Allow long entries", group=group_direction)
i_allow_short = input.bool(true, "Allow short entries", group=group_direction)

// Ensure ranges remain valid even if the user swaps min/max values
validated_min_wait = math.min(i_min_wait_minutes, i_max_wait_minutes)
validated_max_wait = math.max(i_min_wait_minutes, i_max_wait_minutes)
validated_min_ticks = math.min(i_min_tick_distance, i_max_tick_distance)
validated_max_ticks = math.max(i_min_tick_distance, i_max_tick_distance)

// ══════════════════════════════════════════════════════════════════════════════
// STATE
// ══════════════════════════════════════════════════════════════════════════════

var int next_entry_time_ms = na
var int active_tick_distance = na
var string last_direction = "None"
var bool entry_submitted = false
var int entry_submitted_bar = na

const int LOCKED_FUTURE_MS = 32503680000000

// Returns the next time (in ms) when entries are allowed
next_wait_end(time_ms) =>
    wait_minutes = math.round(math.random(validated_min_wait, validated_max_wait))
    wait_minutes := math.max(validated_min_wait, math.min(wait_minutes, validated_max_wait))
    time_ms + wait_minutes * 60 * 1000

trade_finished = strategy.closedtrades > nz(strategy.closedtrades[1], 0)

// Initialize or reschedule the waiting window when starting up or after a trade fully closes
if barstate.isfirst or trade_finished
    next_entry_time_ms := next_wait_end(time)
    active_tick_distance := na
    last_direction := "None"
    entry_submitted := false
    entry_submitted_bar := na

// ══════════════════════════════════════════════════════════════════════════════
// ENTRY LOGIC
// ══════════════════════════════════════════════════════════════════════════════

can_trade = i_allow_long or i_allow_short
is_flat = strategy.position_size == 0
locked_window = not na(next_entry_time_ms) and next_entry_time_ms == LOCKED_FUTURE_MS
cooldown_done = not na(next_entry_time_ms) and not locked_window and time >= next_entry_time_ms
ready_for_entry = is_flat and cooldown_done and can_trade

if ready_for_entry
    // Choose random tick distance for the 1:1 stop/limit
    active_tick_distance := math.round(math.random(validated_min_ticks, validated_max_ticks))
    active_tick_distance := math.max(validated_min_ticks, math.min(active_tick_distance, validated_max_ticks))

    // Flip a coin for direction while respecting disabled sides
    draw_long = math.random(0.0, 1.0) >= 0.5
    is_long = i_allow_long and i_allow_short ? draw_long : i_allow_long

    entry_id = is_long ? "Random Long" : "Random Short"
    last_direction := entry_id
    strategy.entry(entry_id, is_long ? strategy.long : strategy.short)
    entry_submitted := true
    entry_submitted_bar := bar_index
    // Prevent additional entries until the current trade completes
    next_entry_time_ms := LOCKED_FUTURE_MS

// ══════════════════════════════════════════════════════════════════════════════
// EXIT LOGIC
// ══════════════════════════════════════════════════════════════════════════════

long_active = strategy.position_size > 0
short_active = strategy.position_size < 0

if entry_submitted and not is_flat
    // Entry filled; allow resets only after the trade actually closes
    entry_submitted := false
    entry_submitted_bar := na

if long_active and not na(active_tick_distance)
    stop_price_long = strategy.position_avg_price - active_tick_distance * syminfo.mintick
    limit_price_long = strategy.position_avg_price + active_tick_distance * syminfo.mintick
    strategy.exit("Long Exit", from_entry="Random Long", stop=stop_price_long, limit=limit_price_long)

if short_active and not na(active_tick_distance)
    stop_price_short = strategy.position_avg_price + active_tick_distance * syminfo.mintick
    limit_price_short = strategy.position_avg_price - active_tick_distance * syminfo.mintick
    strategy.exit("Short Exit", from_entry="Random Short", stop=stop_price_short, limit=limit_price_short)

// ══════════════════════════════════════════════════════════════════════════════
// RESET AFTER EXIT
// ══════════════════════════════════════════════════════════════════════════════

stuck_locked = locked_window and is_flat and entry_submitted and not na(entry_submitted_bar) and bar_index - entry_submitted_bar > 1

if trade_finished or stuck_locked
    // Closed trade count advanced or a submitted order never filled; clear state and schedule the next window
    next_entry_time_ms := next_wait_end(time)
    active_tick_distance := na
    entry_submitted := false
    entry_submitted_bar := na

// ══════════════════════════════════════════════════════════════════════════════
// PLOTTING (minimal for clarity)
// ══════════════════════════════════════════════════════════════════════════════

plotshape(ready_for_entry, title="Entry Ready", text="Ready", style=shape.triangleup, location=location.bottom, color=color.new(color.teal, 30), size=size.tiny)

// ══════════════════════════════════════════════════════════════════════════════
// DEBUG PANEL
// ══════════════════════════════════════════════════════════════════════════════

var table debug_table = table.new(position.top_right, 1, 1, frame_color=color.new(color.silver, 70), border_width=1)

wait_remaining_min = na(next_entry_time_ms) or locked_window ? na : (next_entry_time_ms - time) / 60000.0
wait_text = locked_window ? "Locked (trade open)" : na(wait_remaining_min) ? "n/a" : wait_remaining_min > 0 ? str.tostring(math.round(wait_remaining_min, 2)) + " min" : "Elapsed"
stop_price_live = long_active and not na(active_tick_distance) ? strategy.position_avg_price - active_tick_distance * syminfo.mintick :
  short_active and not na(active_tick_distance) ? strategy.position_avg_price + active_tick_distance * syminfo.mintick :
  na
close_vs_stop_text = na(stop_price_live) ? "n/a" : str.tostring(close > stop_price_live)
ticks_to_stop = not na(stop_price_live) ? math.abs((close - stop_price_live) / syminfo.mintick) : na
live_tick_text = na(ticks_to_stop) ? "n/a" : str.tostring(math.round(ticks_to_stop, 2))

debug_text = str.format("Random Wait RR 1:1\nReady: {0}\nFlat: {1}\nCooldown Done: {2}\nLocked Window: {3}\nEntry Submitted: {4}\nDirection: {5}\nActive Tick Dist: {6}\nWait Ends: {7}\nCan Trade: {8}\nClose > Stop?: {9}\nTicks To Stop: {10}",
  ready_for_entry,
  is_flat,
  cooldown_done,
  locked_window,
  entry_submitted,
  last_direction,
  na(active_tick_distance) ? "n/a" : str.tostring(active_tick_distance),
  wait_text,
  can_trade,
  close_vs_stop_text,
  live_tick_text)

table.cell(debug_table, 0, 0, debug_text, text_size=size.normal, text_color=color.white, bgcolor=color.new(color.black, 65))

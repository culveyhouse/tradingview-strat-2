// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tradingview-strat-2

//@version=6
//@description="Takes one trade at a time after a random wait, flips a coin for direction, and uses a random 1:1 tick stop/limit."

strategy("Random Wait RR 1:1",
  overlay=true,
  pyramiding=0,
  initial_capital=10000,
  default_qty_type=strategy.percent_of_equity,
  default_qty_value=10,
  process_orders_on_close=true,
  commission_type=strategy.commission.percent,
  commission_value=0.0)

// ══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ══════════════════════════════════════════════════════════════════════════════

group_timing = "Random Timing"
group_risk = "Risk Management"
group_direction = "Direction"

i_min_wait_minutes = input.int(5, "Minimum wait (minutes)", minval=1, maxval=240, group=group_timing)
i_max_wait_minutes = input.int(60, "Maximum wait (minutes)", minval=1, maxval=480, group=group_timing)

i_min_tick_distance = input.int(20, "Minimum tick distance", minval=1, maxval=500, group=group_risk)
i_max_tick_distance = input.int(50, "Maximum tick distance", minval=1, maxval=500, group=group_risk)

i_allow_long = input.bool(true, "Allow long entries", group=group_direction)
i_allow_short = input.bool(true, "Allow short entries", group=group_direction)

// Ensure ranges remain valid even if the user swaps min/max values
validated_min_wait = math.min(i_min_wait_minutes, i_max_wait_minutes)
validated_max_wait = math.max(i_min_wait_minutes, i_max_wait_minutes)
validated_min_ticks = math.min(i_min_tick_distance, i_max_tick_distance)
validated_max_ticks = math.max(i_min_tick_distance, i_max_tick_distance)

// ══════════════════════════════════════════════════════════════════════════════
// STATE
// ══════════════════════════════════════════════════════════════════════════════

var int wait_end_time_ms = na
var int active_tick_distance = na
var bool entry_submitted = false

// Returns the next time (in ms) when entries are allowed
next_wait_end(time_ms) =>
    wait_minutes = math.round(math.random(validated_min_wait, validated_max_wait))
    wait_minutes := math.max(validated_min_wait, math.min(wait_minutes, validated_max_wait))
    time_ms + wait_minutes * 60 * 1000

// Initialize the first waiting window
if na(wait_end_time_ms)
    wait_end_time_ms := next_wait_end(time)

// ══════════════════════════════════════════════════════════════════════════════
// ENTRY LOGIC
// ══════════════════════════════════════════════════════════════════════════════

can_trade = i_allow_long or i_allow_short
ready_for_entry = strategy.position_size == 0 and not entry_submitted and can_trade and time >= wait_end_time_ms

if ready_for_entry
    // Choose random tick distance for the 1:1 stop/limit
    active_tick_distance := math.round(math.random(validated_min_ticks, validated_max_ticks))
    active_tick_distance := math.max(validated_min_ticks, math.min(active_tick_distance, validated_max_ticks))

    // Flip a coin for direction while respecting disabled sides
    draw_long = math.random(0.0, 1.0) >= 0.5
    is_long = i_allow_long and i_allow_short ? draw_long : i_allow_long

    entry_id = is_long ? "Random Long" : "Random Short"
    strategy.entry(entry_id, is_long ? strategy.long : strategy.short)
    entry_submitted := true

// ══════════════════════════════════════════════════════════════════════════════
// EXIT LOGIC
// ══════════════════════════════════════════════════════════════════════════════

long_active = strategy.position_size > 0
short_active = strategy.position_size < 0

if long_active and not na(active_tick_distance)
    stop_price_long = strategy.position_avg_price - active_tick_distance * syminfo.mintick
    limit_price_long = strategy.position_avg_price + active_tick_distance * syminfo.mintick
    strategy.exit("Long Exit", from_entry="Random Long", stop=stop_price_long, limit=limit_price_long)

if short_active and not na(active_tick_distance)
    stop_price_short = strategy.position_avg_price + active_tick_distance * syminfo.mintick
    limit_price_short = strategy.position_avg_price - active_tick_distance * syminfo.mintick
    strategy.exit("Short Exit", from_entry="Random Short", stop=stop_price_short, limit=limit_price_short)

// ══════════════════════════════════════════════════════════════════════════════
// RESET AFTER EXIT
// ══════════════════════════════════════════════════════════════════════════════

if strategy.position_size == 0 and entry_submitted
    active_tick_distance := na
    entry_submitted := false
    wait_end_time_ms := next_wait_end(time)

// ══════════════════════════════════════════════════════════════════════════════
// PLOTTING (minimal for clarity)
// ══════════════════════════════════════════════════════════════════════════════

plotshape(ready_for_entry, title="Entry Ready", text="Ready", style=shape.triangleup, location=location.bottom, color=color.new(color.teal, 30), size=size.tiny)

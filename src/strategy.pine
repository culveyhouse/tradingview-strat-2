// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © tradingview-strat-2

//@version=6
// A deliberately simple random-entry strategy with 1:1 risk/reward and fixed commissions.
strategy(title="Random 1:1 R:R", shorttitle="Random R:R", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, commission_type=strategy.commission.cash_per_order, commission_value=1.0)

// ══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ══════════════════════════════════════════════════════════════════════════════

// Strategy behavior
probability_per_bar = input.float(1.0, "Entry Chance (0-1)", minval=0.0, maxval=1.0, step=0.05, tooltip="Chance of opening a trade when flat on any given bar.", group="Strategy Settings")
enable_long = input.bool(true, "Allow Long Entries", group="Strategy Settings")
enable_short = input.bool(true, "Allow Short Entries", group="Strategy Settings")

// Tick range for both stop loss and take profit (1:1 R:R)
min_ticks = input.int(20, "Minimum Stop/Limit Ticks", minval=1, group="Risk Settings")
max_ticks = input.int(50, "Maximum Stop/Limit Ticks", minval=1, group="Risk Settings")

// Sanitize ranges to avoid invalid inputs.
min_ticks_clean = math.max(1, min_ticks)
max_ticks_clean = math.max(min_ticks_clean, max_ticks)

// ══════════════════════════════════════════════════════════════════════════════
// RANDOM HELPERS
// ══════════════════════════════════════════════════════════════════════════════

// Pseudo-random number generator based on bar_index for reproducibility.
rand_float(src) =>
    raw = math.sin(src) * 43758.5453
    raw - math.floor(raw)
rand_between(min_val, max_val, src) => min_val + rand_float(src) * (max_val - min_val)

// ══════════════════════════════════════════════════════════════════════════════
// STATE
// ══════════════════════════════════════════════════════════════════════════════

var int active_ticks = na
var int wait_bars_target = 0
var int bars_waited_flat = 0
var bool was_in_position = false
is_flat = strategy.position_size == 0
just_exited = was_in_position and is_flat

// When a position closes, draw a random flat-period length before the next entry.
if just_exited
    wait_bars_target := math.round(rand_between(1.0, 61.0, bar_index + 101))
    wait_bars_target := math.max(wait_bars_target, 1)
    bars_waited_flat := 0

// Reset active trade settings when flat so a fresh draw happens on next entry, and count flat bars.
if is_flat
    active_ticks := na
    bars_waited_flat := just_exited ? 0 : bars_waited_flat + 1
else
    bars_waited_flat := 0

// Track last known position state for exit detection.
was_in_position := not is_flat

// Sources for random draws per bar.
rand_seed_dir = bar_index + 1
rand_seed_ticks = bar_index + 7
rand_seed_chance = bar_index + 13

rand_dir_long = rand_float(rand_seed_dir) >= 0.5
rand_ticks_raw = rand_between(min_ticks_clean, max_ticks_clean + 1.0, rand_seed_ticks)
rand_ticks = math.round(rand_ticks_raw)

// Guarantee at least one attempt on the first visible bar so the strategy produces trades even on short chart windows.
should_try_entry = rand_float(rand_seed_chance) < probability_per_bar or probability_per_bar >= 1.0
force_first_entry = barstate.isfirst
waiting_finished = bars_waited_flat >= wait_bars_target
should_enter = is_flat and waiting_finished and not na(rand_ticks) and (should_try_entry or force_first_entry)

// ══════════════════════════════════════════════════════════════════════════════
// ENTRY LOGIC
// ══════════════════════════════════════════════════════════════════════════════

can_long = enable_long and (rand_dir_long or not enable_short)
can_short = enable_short and (not rand_dir_long or not enable_long)

if should_enter
    // Store the tick distance for this trade so exits remain constant while open.
    active_ticks := rand_ticks
    if can_long
        strategy.entry("Long", strategy.long)
    if can_short
        strategy.entry("Short", strategy.short)

// ══════════════════════════════════════════════════════════════════════════════
// EXIT LOGIC (1:1 R:R)
// ══════════════════════════════════════════════════════════════════════════════

has_ticks = not na(active_ticks)
tick_distance = float(active_ticks) * syminfo.mintick

if strategy.position_size > 0 and has_ticks
    entry_price = strategy.position_avg_price
    strategy.exit("Long Exit", from_entry="Long", stop=entry_price - tick_distance, limit=entry_price + tick_distance)

if strategy.position_size < 0 and has_ticks
    entry_price = strategy.position_avg_price
    strategy.exit("Short Exit", from_entry="Short", stop=entry_price + tick_distance, limit=entry_price - tick_distance)

// ══════════════════════════════════════════════════════════════════════════════
// PLOTTING
// ══════════════════════════════════════════════════════════════════════════════

plotshape(strategy.position_size > 0, title="Long Active", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.tiny)
plotshape(strategy.position_size < 0, title="Short Active", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.tiny)
